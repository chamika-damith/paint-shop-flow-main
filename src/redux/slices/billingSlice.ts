import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { BillingState, Invoice, Receipt } from '@/types';
import { billingApi } from '@/api/billingApi';

const initialState: BillingState = {
  invoices: [],
  receipts: [],
  loading: false,
  error: null,
};

// Async thunks for invoices
export const fetchInvoices = createAsyncThunk(
  'billing/fetchInvoices',
  async (_, { rejectWithValue }) => {
    try {
      const response = await billingApi.getAllInvoices();
      console.log(response.data);
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.message || 'Failed to fetch invoices');
    }
  }
);

export const addInvoice = createAsyncThunk(
  'billing/addInvoice',
  async (invoice: Omit<Invoice, '_id'>, { rejectWithValue }) => {
    try {
      console.log('Creating invoice with data:', invoice);
      const response = await billingApi.createInvoice(invoice);
      return response.data;
    } catch (error: any) {
      console.error('Error in addInvoice:', error.response?.data || error);
      return rejectWithValue(error.response?.data?.message || 'Failed to add invoice');
    }
  }
);

export const updateInvoice = createAsyncThunk(
  'billing/updateInvoice',
  async ({ id, invoice }: { id: string; invoice: Partial<Invoice> }, { rejectWithValue }) => {
    try {
      console.log('Updating invoice:', { id, invoice });
      const response = await billingApi.updateInvoice(id, invoice);
      return response.data;
    } catch (error: any) {
      console.error('Error updating invoice:', error.response?.data || error);
      return rejectWithValue(error.response?.data?.message || 'Failed to update invoice');
    }
  }
);

export const deleteInvoice = createAsyncThunk(
  'billing/deleteInvoice',
  async (id: string, { rejectWithValue }) => {
    try {
      await billingApi.deleteInvoice(id);
      return id;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.message || 'Failed to delete invoice');
    }
  }
);

export const markInvoiceAsPaid = createAsyncThunk(
  'billing/markInvoiceAsPaid',
  async (id: string, { dispatch, rejectWithValue }) => {
    try {
      const response = await billingApi.markInvoiceAsPaid(id);
      // After marking as paid, create a receipt
      const invoice = response.data;
      await dispatch(addReceipt({
        _id: undefined, // This will be generated by MongoDB
        customer: invoice.customer,
        date: new Date().toISOString(),
        amount: invoice.amount,
        items: invoice.items.length,
        invoice: invoice._id
      }));
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.message || 'Failed to mark invoice as paid');
    }
  }
);

// Async thunks for receipts
export const fetchReceipts = createAsyncThunk(
  'billing/fetchReceipts',
  async (_, { rejectWithValue }) => {
    try {
      const response = await billingApi.getAllReceipts();
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.message || 'Failed to fetch receipts');
    }
  }
);

export const addReceipt = createAsyncThunk(
  'billing/addReceipt',
  async (receipt: Omit<Receipt, 'id'>, { rejectWithValue }) => {
    try {
      const response = await billingApi.createReceipt(receipt);
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.message || 'Failed to add receipt');
    }
  }
);

export const updateReceipt = createAsyncThunk(
  'billing/updateReceipt',
  async ({ id, receipt }: { id: string; receipt: Partial<Receipt> }, { rejectWithValue }) => {
    try {
      const response = await billingApi.updateReceipt(id, receipt);
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.message || 'Failed to update receipt');
    }
  }
);

export const deleteReceipt = createAsyncThunk(
  'billing/deleteReceipt',
  async (id: string, { rejectWithValue }) => {
    try {
      await billingApi.deleteReceipt(id);
      return id;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.message || 'Failed to delete receipt');
    }
  }
);

export const emailReceipt = createAsyncThunk(
  'billing/emailReceipt',
  async ({ id, email }: { id: string; email: string }, { rejectWithValue }) => {
    try {
      await billingApi.emailReceipt(id, email);
      return id;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.message || 'Failed to email receipt');
    }
  }
);

const billingSlice = createSlice({
  name: 'billing',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      // Fetch invoices
      .addCase(fetchInvoices.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchInvoices.fulfilled, (state, action) => {
        state.loading = false;
        state.invoices = action.payload;
      })
      .addCase(fetchInvoices.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      // Add invoice
      .addCase(addInvoice.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(addInvoice.fulfilled, (state, action) => {
        state.loading = false;
        state.invoices.push(action.payload);
      })
      .addCase(addInvoice.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      // Update invoice
      .addCase(updateInvoice.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(updateInvoice.fulfilled, (state, action) => {
        state.loading = false;
        const index = state.invoices.findIndex((invoice) => invoice._id === action.payload._id);
        if (index !== -1) {
          state.invoices[index] = action.payload;
        }
      })
      .addCase(updateInvoice.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      // Delete invoice
      .addCase(deleteInvoice.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(deleteInvoice.fulfilled, (state, action) => {
        state.loading = false;
        state.invoices = state.invoices.filter((invoice) => invoice._id !== action.payload);
      })
      .addCase(deleteInvoice.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      // Mark invoice as paid
      .addCase(markInvoiceAsPaid.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(markInvoiceAsPaid.fulfilled, (state, action) => {
        state.loading = false;
        const index = state.invoices.findIndex((invoice) => invoice._id === action.payload._id);
        if (index !== -1) {
          state.invoices[index] = action.payload;
        }
      })
      .addCase(markInvoiceAsPaid.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      // Fetch receipts
      .addCase(fetchReceipts.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchReceipts.fulfilled, (state, action) => {
        state.loading = false;
        state.receipts = action.payload;
      })
      .addCase(fetchReceipts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      // Add receipt
      .addCase(addReceipt.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(addReceipt.fulfilled, (state, action) => {
        state.loading = false;
        state.receipts.push(action.payload);
      })
      .addCase(addReceipt.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      // Update receipt
      .addCase(updateReceipt.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(updateReceipt.fulfilled, (state, action) => {
        state.loading = false;
        const index = state.receipts.findIndex((receipt) => receipt._id === action.payload._id);
        if (index !== -1) {
          state.receipts[index] = action.payload;
        }
      })
      .addCase(updateReceipt.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      // Delete receipt
      .addCase(deleteReceipt.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(deleteReceipt.fulfilled, (state, action) => {
        state.loading = false;
        state.receipts = state.receipts.filter((receipt) => receipt._id !== action.payload);
      })
      .addCase(deleteReceipt.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      // Email receipt
      .addCase(emailReceipt.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(emailReceipt.fulfilled, (state) => {
        state.loading = false;
      })
      .addCase(emailReceipt.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      });
  },
});

export default billingSlice.reducer; 